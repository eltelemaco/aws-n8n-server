name: Deploy via SSM

# This workflow deploys n8n stack updates to the EC2 instance via AWS Systems Manager (SSM).
# It uses IAM-based authentication (GitHub OIDC preferred) and SSM Run Command for deployment
# execution, providing centralized audit logging and eliminating SSH key management.
#
# Required Setup:
#   Option A - GitHub OIDC (Recommended):
#     1. Create IAM OIDC provider in AWS:
#        - Provider URL: https://token.actions.githubusercontent.com
#        - Audience: sts.amazonaws.com
#     2. Create IAM role with trust policy for your GitHub repository
#     3. Attach policy with permissions:
#        - ec2:DescribeInstances
#        - ssm:SendCommand
#        - ssm:GetCommandInvocation
#        - ssm:ListCommandInvocations
#     4. Set GitHub variable:
#        - AWS_ROLE_ARN: arn:aws:iam::ACCOUNT_ID:role/GitHubActionsRole
#        - AWS_REGION: us-east-1 (or your region)
#
#   Option B - AWS Access Keys (Fallback):
#     Set GitHub Secrets:
#       - AWS_ACCESS_KEY_ID: AWS access key ID
#       - AWS_SECRET_ACCESS_KEY: AWS secret access key
#       - AWS_REGION: us-east-1 (or your region)
#
# Deployment Process:
#   1. Authenticates with AWS via OIDC or access keys
#   2. Locates EC2 instance by tags
#   3. Copies wrapper script to EC2 via SSM document
#   4. Copies configuration files to EC2
#   5. Executes wrapper script via SSM Send-Command
#   6. Monitors command execution and retrieves output
#   7. Reports deployment status
#
# The wrapper script (ssm-deploy-wrapper.sh) calls the main deployment script
# (update-stack.sh) which performs:
#   - Backup of current configuration
#   - Graceful service shutdown
#   - Service restart with new configuration
#   - Health check verification
#   - Automatic rollback on failure

on:
  # Manual trigger for on-demand deployments
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for deployment'
        required: false
        default: 'Manual SSM deployment'
        type: string

  # Automatic trigger on push to main for relevant file changes
  push:
    branches:
      - main
    paths:
      - 'infra/live/prod/user_data/docker-compose.yml.tftpl'
      - 'infra/live/prod/user_data/traefik-static.yml.tftpl'
      - 'infra/live/prod/user_data/systemd-service.tftpl'
      - 'scripts/update-stack.sh'
      - 'scripts/ssm-deploy-wrapper.sh'
      - '.github/workflows/deploy-ssm.yml'

jobs:
  deploy:
    name: Deploy via SSM
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      id-token: write   # Required for OIDC
      contents: read    # Required for checkout

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify deployment scripts exist
        run: |
          if [[ ! -f scripts/update-stack.sh ]]; then
            echo "Error: Main deployment script not found at scripts/update-stack.sh"
            exit 1
          fi
          if [[ ! -f scripts/ssm-deploy-wrapper.sh ]]; then
            echo "Error: SSM wrapper script not found at scripts/ssm-deploy-wrapper.sh"
            exit 1
          fi
          echo "Deployment scripts verified"

      - name: Configure AWS credentials (OIDC)
        if: vars.AWS_ROLE_ARN != ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}
          role-session-name: GitHubActions-SSM-Deploy

      - name: Configure AWS credentials (Access Keys)
        if: vars.AWS_ROLE_ARN == ''
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || vars.AWS_REGION || 'us-east-1' }}

      - name: Verify AWS authentication
        run: |
          echo "Verifying AWS authentication..."
          aws sts get-caller-identity
          echo "AWS authentication successful"

      - name: Get EC2 instance ID
        id: get-instance
        run: |
          echo "Locating EC2 instance..."

          # Try to get instance ID from GitHub variable first
          if [[ -n "${{ vars.EC2_INSTANCE_ID }}" ]]; then
            INSTANCE_ID="${{ vars.EC2_INSTANCE_ID }}"
            echo "Using instance ID from GitHub variable: ${INSTANCE_ID}"
          else
            # Fallback: Find instance by tags (adjust tags as needed)
            INSTANCE_ID=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=*n8n*" \
                        "Name=instance-state-name,Values=running" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)

            if [[ "${INSTANCE_ID}" == "None" ]] || [[ -z "${INSTANCE_ID}" ]]; then
              echo "Error: Could not find running EC2 instance"
              echo "Please set EC2_INSTANCE_ID as a GitHub variable or ensure instance has Name tag containing 'n8n'"
              exit 1
            fi

            echo "Found instance ID via tags: ${INSTANCE_ID}"
          fi

          echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT
          echo "EC2 Instance ID: ${INSTANCE_ID}"

      - name: Verify SSM connectivity
        run: |
          echo "Verifying SSM agent connectivity..."
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Check if instance is managed by SSM
          SSM_STATUS=$(aws ssm describe-instance-information \
            --filters "Key=InstanceIds,Values=${INSTANCE_ID}" \
            --query "InstanceInformationList[0].PingStatus" \
            --output text)

          if [[ "${SSM_STATUS}" != "Online" ]]; then
            echo "Error: SSM agent is not online for instance ${INSTANCE_ID}"
            echo "SSM Status: ${SSM_STATUS}"
            echo "Please ensure SSM agent is running and instance has proper IAM role"
            exit 1
          fi

          echo "SSM agent is online and ready"

      - name: Copy wrapper script to EC2
        run: |
          echo "Copying SSM wrapper script to EC2..."
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Read wrapper script content
          WRAPPER_SCRIPT=$(cat scripts/ssm-deploy-wrapper.sh)

          # Execute command to write wrapper script to EC2
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy SSM wrapper script" \
            --parameters commands="[
              \"cat > /tmp/ssm-deploy-wrapper.sh << 'WRAPPER_EOF'\",
              \"${WRAPPER_SCRIPT}\",
              \"WRAPPER_EOF\",
              \"sudo mv /tmp/ssm-deploy-wrapper.sh /opt/stacks/n8n/ssm-deploy-wrapper.sh\",
              \"sudo chmod +x /opt/stacks/n8n/ssm-deploy-wrapper.sh\",
              \"echo 'Wrapper script deployed successfully'\"
            ]" \
            --output text \
            --query "Command.CommandId")

          echo "Command ID: ${COMMAND_ID}"

          # Wait for command completion
          echo "Waiting for script copy to complete..."
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --timeout 60

          # Check command status
          STATUS=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" \
            --output text)

          if [[ "${STATUS}" != "Success" ]]; then
            echo "Error: Failed to copy wrapper script"
            aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi

          echo "Wrapper script copied successfully"

      - name: Copy configuration files to EC2
        run: |
          echo "Copying updated docker-compose template to EC2..."
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Read docker-compose template
          COMPOSE_TEMPLATE=$(cat infra/live/prod/user_data/docker-compose.yml.tftpl)

          # Execute command to render and deploy docker-compose.yml
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Update docker-compose configuration" \
            --parameters commands="[
              \"cat > /tmp/docker-compose.yml.tftpl << 'COMPOSE_EOF'\",
              \"${COMPOSE_TEMPLATE}\",
              \"COMPOSE_EOF\",
              \"cd /opt/stacks/n8n\",
              \"if [[ -f .env ]]; then set -a; source .env; set +a; fi\",
              \"envsubst < /tmp/docker-compose.yml.tftpl > /tmp/docker-compose.yml\",
              \"sudo mv /tmp/docker-compose.yml /opt/stacks/n8n/docker-compose.yml\",
              \"sudo chown root:root /opt/stacks/n8n/docker-compose.yml\",
              \"sudo chmod 644 /opt/stacks/n8n/docker-compose.yml\",
              \"rm -f /tmp/docker-compose.yml.tftpl\",
              \"echo 'Configuration files updated successfully'\"
            ]" \
            --output text \
            --query "Command.CommandId")

          echo "Command ID: ${COMMAND_ID}"

          # Wait for command completion
          echo "Waiting for configuration update to complete..."
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --timeout 60

          # Check command status
          STATUS=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" \
            --output text)

          if [[ "${STATUS}" != "Success" ]]; then
            echo "Error: Failed to copy configuration files"
            aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi

          echo "Configuration files copied successfully"

      - name: Execute deployment via SSM
        id: deploy
        run: |
          echo "Starting deployment on EC2 instance via SSM..."
          echo "Deployment reason: ${{ github.event.inputs.reason || 'Automatic deployment from push to main' }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Commit: ${{ github.sha }}"
          echo "----------------------------------------"

          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Execute deployment wrapper script
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy n8n stack update - ${{ github.event.inputs.reason || 'Auto deployment' }}" \
            --timeout-seconds 600 \
            --parameters commands="[
              \"sudo /opt/stacks/n8n/ssm-deploy-wrapper.sh\"
            ]" \
            --output text \
            --query "Command.CommandId")

          echo "SSM Command ID: ${COMMAND_ID}"
          echo "command_id=${COMMAND_ID}" >> $GITHUB_OUTPUT

          # Wait for command completion (with timeout)
          echo "Waiting for deployment to complete (timeout: 10 minutes)..."
          if aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --timeout 600; then
            echo "Command execution completed"
          else
            echo "Warning: Command wait timed out or failed"
          fi

          # Get command status
          STATUS=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" \
            --output text)

          echo "Deployment status: ${STATUS}"
          echo "deployment_status=${STATUS}" >> $GITHUB_OUTPUT

          # Get command output
          echo "----------------------------------------"
          echo "Deployment Output:"
          aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text

          # Check for errors
          if [[ "${STATUS}" != "Success" ]]; then
            echo "----------------------------------------"
            echo "Deployment Errors:"
            aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query "StandardErrorContent" \
              --output text
            exit 1
          fi

          echo "----------------------------------------"
          echo "Deployment completed successfully via SSM"

      - name: Verify deployment
        if: steps.deploy.outputs.deployment_status == 'Success'
        run: |
          echo "Verifying deployment..."
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Check running containers
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Verify deployment" \
            --parameters commands="[
              \"cd /opt/stacks/n8n\",
              \"sudo docker compose ps --format json\"
            ]" \
            --output text \
            --query "Command.CommandId")

          # Wait for verification command
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --timeout 60

          # Get container status
          echo "Container Status:"
          aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text | jq -r 'select(.) | "\(.Service): \(.State) (\(.Status))"' || echo "Unable to parse container status"

          echo "----------------------------------------"
          echo "Deployment verification completed"

      - name: Fetch deployment logs on failure
        if: failure()
        run: |
          echo "========================================="
          echo "Deployment failed - fetching logs for debugging"
          echo "========================================="
          INSTANCE_ID="${{ steps.get-instance.outputs.instance_id }}"

          # Get deployment logs
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Fetch deployment logs" \
            --parameters commands="[
              \"echo '--- SSM Deployment logs ---'\",
              \"sudo tail -n 100 /var/log/ssm-deployment.log 2>/dev/null || echo 'No SSM logs available'\",
              \"echo ''\",
              \"echo '--- n8n Deployment logs ---'\",
              \"sudo tail -n 100 /var/log/n8n-deployment.log 2>/dev/null || echo 'No deployment logs available'\",
              \"echo ''\",
              \"echo '--- Docker service status ---'\",
              \"cd /opt/stacks/n8n && sudo docker compose ps 2>/dev/null || echo 'Cannot retrieve container status'\",
              \"echo ''\",
              \"echo '--- Recent docker logs ---'\",
              \"cd /opt/stacks/n8n && sudo docker compose logs --tail=50 2>/dev/null || echo 'Cannot retrieve docker logs'\"
            ]" \
            --output text \
            --query "Command.CommandId")

          # Wait for log fetch
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --timeout 120

          # Display logs
          aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text

      - name: Report deployment status
        if: always()
        run: |
          if [[ "${{ steps.deploy.outputs.deployment_status }}" == "Success" ]]; then
            echo "Deployment completed successfully via SSM"
            echo "Deployed by: ${{ github.actor }}"
            echo "Commit: ${{ github.sha }}"
            echo "Reason: ${{ github.event.inputs.reason || 'Automatic deployment from push to main' }}"
            echo "SSM Command ID: ${{ steps.deploy.outputs.command_id }}"
          else
            echo "Deployment failed via SSM"
            echo "Status: ${{ steps.deploy.outputs.deployment_status }}"
            echo "Check logs above for details"
            echo "SSM Command ID: ${{ steps.deploy.outputs.command_id }}"
            exit 1
          fi
